import React, { useState, useEffect } from "react";
import "./App.css";
import {
  fetchPantryItems,
  createPantryItem,
  fetchRecipeChat,
  sendFeedback,
} from "./api";
import type {
  PantryItem,
  RecipeSuggestion,
  FeedbackRequest,
} from "./api";
import PantryTab from "./PantryTab";

type Tab = "dashboard" | "chat" | "pantry";
type Theme = "light" | "dark";

function DashboardTab() {
  const [items, setItems] = useState<PantryItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    setLoading(true);
    fetchPantryItems()
      .then(setItems)
      .catch((err) => {
        console.error(err);
        setError("Could not load pantry summary.");
      })
      .finally(() => setLoading(false));
  }, []);

  const totalItems = items.length;
  const totalQuantity = items.reduce(
    (sum, it) => sum + (it.quantity ?? 0),
    0
  );
  const distinctCategories = new Set(
    items
      .map((it) => (it.category ?? "").trim())
      .filter((c) => c.length > 0)
  ).size;

  return (
    <div className="panel">
      <h2 className="panel-title">Pantry Overview</h2>
      <p className="panel-subtitle">
        High-level snapshot of what&apos;s in your pantry based on live data.
      </p>

      {loading && <p className="card-text">Loading pantry summary…</p>}
      {error && (
        <p className="card-text" style={{ color: "#b91c1c" }}>
          {error}
        </p>
      )}

      {/* Stat cards */}
      <div className="stat-grid">
        <div className="card">
          <div className="stat-label">Total items</div>
          <div className="stat-number">{totalItems}</div>
          <div className="stat-help">
            Count of distinct rows in your Item table.
          </div>
        </div>
        <div className="card">
          <div className="stat-label">Total quantity</div>
          <div className="stat-number">{totalQuantity}</div>
          <div className="stat-help">
            Sum of the quantity field across all items.
          </div>
        </div>
        <div className="card">
          <div className="stat-label">Categories</div>
          <div className="stat-number">{distinctCategories}</div>
          <div className="stat-help">
            Number of distinct item categories in your pantry.
          </div>
        </div>
      </div>

      <div className="split-grid">
        {/* Data viz card with actual images */}
        <div className="card">
          <h3 className="card-title">Data Visualization</h3>
          <p className="card-text">
            These charts show how meals cluster together based on their
            underlying data (like nutrition). They&apos;re a preview of how
            Pantry AI can group foods into patterns that drive smarter
            recommendations on this dashboard.
          </p>

          <div className="viz-placeholder">
            <div>
              <img
                src="/kmeans_pca_scatter.png"
                alt="K-means clusters in PCA space"
                className="viz-image"
              />
              <p className="viz-caption">
                K-means clusters in a 2D space after PCA. Each dot is a meal;
                colors show which cluster it belongs to.
              </p>
            </div>

            <div>
              <img
                src="/kmeans_pca_clusters_k3.png"
                alt="K-means clustering with 3 clusters"
                className="viz-image"
              />
              <p className="viz-caption">
                The same data grouped into 3 broader clusters. This helps us see
                high-level patterns in how meals are organized.
              </p>
            </div>
          </div>
        </div>

        {/* Highlights / insights card */}
        <div className="card">
          <h3 className="card-title">Highlights</h3>
          <ul className="highlights">
            <li>
              Total items: <strong>{totalItems}</strong>
            </li>
            <li>
              Total quantity across items: <strong>{totalQuantity}</strong>
            </li>
            <li>
              Distinct categories: <strong>{distinctCategories}</strong>
            </li>
          </ul>
          <p className="card-text">
            These highlights are now driven directly by your pantry data, while
            the charts on the left show how we can cluster meals to power future
            recommendations.
          </p>
        </div>
      </div>
    </div>
  );
}

type ChatMessage = {
  sender: "user" | "assistant";
  text: string;
};

type RecipeCardData = {
  recipe: RecipeSuggestion;
  showFeedbackUI: boolean;
};

function ChatTab() {
  // Chat message state
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([
    {
      sender: "assistant",
      text: "Hi! I'm your Pantry AI assistant. What would you like to do today?",
    },
  ]);
  const [chatInput, setChatInput] = useState("");
  const [chatLoading, setChatLoading] = useState(false);
  const [chatError, setChatError] = useState<string | null>(null);

  // Guided pathway state
  const [showActions, setShowActions] = useState(true);
  const [showGetRecipeCard, setShowGetRecipeCard] = useState(false);
  const [gr_include, setGrInclude] = useState("");
  const [gr_exclude, setGrExclude] = useState("");
  const [gr_diet, setGrDiet] = useState("");
  const [gr_maxTime, setGrMaxTime] = useState<string>("");
  const [gr_mood, setGrMood] = useState<string>("Neutral");
  const [gr_energy, setGrEnergy] = useState<string>("Medium");

  // Recipe suggestions from /chat/recipes endpoint
  const [currentRecipes, setCurrentRecipes] = useState<RecipeCardData[]>([]);

  // Feedback UI state for currently selected recipe
  const [feedbackRecipe, setFeedbackRecipe] = useState<RecipeSuggestion | null>(
    null
  );
  const [feedbackData, setFeedbackData] = useState({
    rating: 3,
    likedTags: [] as string[],
    dislikedTags: [] as string[],
    feelAfter: "",
    notes: "",
  });
  const [feedbackLoading, setFeedbackLoading] = useState(false);

  // Common tag options
  const commonLikedTags = [
    "spicy",
    "tangy",
    "fresh",
    "creamy",
    "light",
    "comforting",
  ];
  const commonDislikedTags = [
    "spicy",
    "tangy",
    "greasy",
    "bland",
    "heavy",
    "bitter",
  ];
  const feelAfterOptions = [
    "energized",
    "focused",
    "neutral",
    "sluggish",
    "overfull",
  ];

  // Handle sending a natural language message to /chat/recipes
  async function handleSendChat(e: React.FormEvent) {
    e.preventDefault();
    const trimmed = chatInput.trim();
    if (!trimmed || chatLoading) return;

    // Add user message
    const userMsg: ChatMessage = { sender: "user", text: trimmed };
    setChatMessages((prev) => [...prev, userMsg]);
    setChatInput("");
    setChatError(null);
    setChatLoading(true);

    try {
      // Call the new /chat/recipes endpoint
      const result = await fetchRecipeChat(trimmed);

      // Add assistant reply
      const assistantMsg: ChatMessage = {
        sender: "assistant",
        text: result.reply,
      };
      setChatMessages((prev) => [...prev, assistantMsg]);

      // Store the recipes for display
      setCurrentRecipes(
        result.recipes.map((r) => ({ recipe: r, showFeedbackUI: false }))
      );
    } catch (err) {
      console.error(err);
      setChatError("Sorry, something went wrong. Please try again.");
      // Add error message to chat
      const errorMsg: ChatMessage = {
        sender: "assistant",
        text: "I encountered an error processing your request. Please try again.",
      };
      setChatMessages((prev) => [...prev, errorMsg]);
    } finally {
      setChatLoading(false);
    }
  }

  function handleOpenGetRecipe() {
    // append assistant prompt and show criteria card
    const assistantMsg: ChatMessage = {
      sender: "assistant",
      text: "Great! Let's find something to cook. Tell me a bit about what you're looking for:",
    };
    setChatMessages((prev) => [...prev, assistantMsg]);
    setShowActions(false);
    setShowGetRecipeCard(true);
  }

  function handleCancelGetRecipe() {
    setShowGetRecipeCard(false);
    setShowActions(true);
    // clear fields
    setGrInclude("");
    setGrExclude("");
    setGrDiet("");
    setGrMaxTime("");
    setGrMood("Neutral");
    setGrEnergy("Medium");
  }

  async function handleGetRecipesClick() {
    // Build structured JSON payload
    const includeList = gr_include.trim() ? gr_include.split(",").map(s => s.trim()).filter(s => s) : [];
    const excludeList = gr_exclude.trim() ? gr_exclude.split(",").map(s => s.trim()).filter(s => s) : [];
    const maxTime = gr_maxTime.trim() ? parseInt(gr_maxTime) : null;
    
    const payload = {
      mood: gr_mood,
      energy: gr_energy,
      diet: gr_diet || null,
      include_ingredients: includeList.length > 0 ? includeList : null,
      exclude_ingredients: excludeList.length > 0 ? excludeList : null,
      max_time_minutes: maxTime,
    };

    // Display user message summarizing their choices
    const parts: string[] = [];
    parts.push(`Mood: ${gr_mood}`);
    parts.push(`Energy: ${gr_energy}`);
    if (gr_diet) parts.push(`Diet: ${gr_diet}`);
    if (includeList.length > 0) parts.push(`Include: ${includeList.join(", ")}`);
    if (excludeList.length > 0) parts.push(`Exclude: ${excludeList.join(", ")}`);
    if (maxTime) parts.push(`Time: under ${maxTime} min`);
    
    const userMsg: ChatMessage = { sender: "user", text: `Looking for a recipe: ${parts.join(" • ")}` };
    setChatMessages((prev) => [...prev, userMsg]);
    setChatLoading(true);

    try {
      const result = await fetchRecipeChat(payload);
      const assistantMsg: ChatMessage = {
        sender: "assistant",
        text: result.reply,
      };
      setChatMessages((prev) => [...prev, assistantMsg]);
      setCurrentRecipes(
        result.recipes.map((r) => ({ recipe: r, showFeedbackUI: false }))
      );
    } catch (err) {
      console.error(err);
      const errorMsg: ChatMessage = {
        sender: "assistant",
        text: "I encountered an error processing your request. Please try again.",
      };
      setChatMessages((prev) => [...prev, errorMsg]);
    } finally {
      setChatLoading(false);
    }

    // hide the card after submission
    setShowGetRecipeCard(false);
    setShowActions(true);
  }

  // Handle "Cooked this" button — open feedback UI for a recipe
  function handleCookedThis(recipe: RecipeSuggestion) {
    setFeedbackRecipe(recipe);
    setFeedbackData({
      rating: 3,
      likedTags: [],
      dislikedTags: [],
      feelAfter: "",
      notes: "",
    });
  }

  // Toggle a tag in liked/disliked lists
  function toggleTag(
    tag: string,
    type: "liked" | "disliked"
  ) {
    setFeedbackData((prev) => {
      const arr =
        type === "liked" ? [...prev.likedTags] : [...prev.dislikedTags];
      const idx = arr.indexOf(tag);
      if (idx >= 0) {
        arr.splice(idx, 1);
      } else {
        arr.push(tag);
      }
      return type === "liked"
        ? { ...prev, likedTags: arr }
        : { ...prev, dislikedTags: arr };
    });
  }

  // Handle feedback submission
  async function handleSubmitFeedback() {
    if (!feedbackRecipe) return;

    setFeedbackLoading(true);
    try {
      const feedback: FeedbackRequest = {
        recipe_id: feedbackRecipe.recipe_id,
        recipe_title: feedbackRecipe.title,
        taste_rating: feedbackData.rating,
        liked_tags:
          feedbackData.likedTags.length > 0
            ? feedbackData.likedTags
            : undefined,
        disliked_tags:
          feedbackData.dislikedTags.length > 0
            ? feedbackData.dislikedTags
            : undefined,
        feel_after: feedbackData.feelAfter || undefined,
        notes: feedbackData.notes || undefined,
      };

      await sendFeedback(feedback);

      // Add a friendly assistant message
      const confirmMsg: ChatMessage = {
        sender: "assistant",
        text: `Thanks! I've saved that you ${feedbackData.rating >= 4 ? "loved" : feedbackData.rating >= 3 ? "liked" : "didn't love"} the ${feedbackRecipe.title}. I'll remember these preferences for future recommendations!`,
      };
      setChatMessages((prev) => [...prev, confirmMsg]);

      // Close feedback UI
      setFeedbackRecipe(null);
    } catch (err) {
      console.error(err);
      alert("Failed to save feedback. Please try again.");
    } finally {
      setFeedbackLoading(false);
    }
  }

  return (
    <div className="panel">
      <h2 className="panel-title">Chat with Pantry AI</h2>
      <p className="panel-subtitle">
        Ask me natural questions like "What can I make that's quick and high
        protein?" and I'll suggest recipes from your pantry.
      </p>

      {/* Guided actions */}
      {showActions && (
        <div style={{ marginBottom: 12 }}>
          <button className="tag-chip" onClick={handleOpenGetRecipe}>
            Get a recipe
          </button>
          <button
            className="tag-chip"
            onClick={() => {
              const assistantMsg: ChatMessage = {
                sender: "assistant",
                text: "That feature is coming soon! For now, try 'Get a recipe'.",
              };
              setChatMessages((prev) => [...prev, assistantMsg]);
            }}
          >
            Log how a meal made me feel
          </button>
          <button
            className="tag-chip"
            onClick={() => {
              const assistantMsg: ChatMessage = {
                sender: "assistant",
                text: "That feature is coming soon! For now, try 'Get a recipe'.",
              };
              setChatMessages((prev) => [...prev, assistantMsg]);
            }}
          >
            Review or adjust my pantry
          </button>
        </div>
      )}

      {/* Criteria card moved into chat history so it appears under the assistant prompt */}

      <div className="chat-container">
        {/* Chat history + recipes */}
        <div className="chat-history">
          {chatMessages.map((m, idx) => (
            <div key={idx} className={`chat-bubble ${m.sender}`}>
              <div className="chat-label">
                {m.sender === "user" ? "You" : "Pantry AI"}
              </div>
              <div className="chat-text">{m.text}</div>
            </div>
          ))}

          {/* Render criteria card inside chat history so it appears after the assistant prompt */}
          {showGetRecipeCard && (
            <div className="card" style={{ margin: "8px 0" }}>
              <h3 className="card-title">Get a recipe</h3>
              <div className="form-grid">
                <label>
                  <span>What's your current mood?</span>
                  <div style={{ display: "flex", gap: 8, marginTop: 6, flexWrap: "wrap" }}>
                    {["Neutral", "Stressed or anxious", "Low or a bit down", "Excited or social"].map((m) => (
                      <button
                        key={m}
                        type="button"
                        className={`tag-chip ${gr_mood === m ? "active" : ""}`}
                        onClick={() => setGrMood(m)}
                      >
                        {m}
                      </button>
                    ))}
                  </div>
                </label>

                <label>
                  <span>How's your energy?</span>
                  <div style={{ display: "flex", gap: 8, marginTop: 6 }}>
                    {[{ key: "Low", label: "Low" }, { key: "Medium", label: "Medium" }, { key: "High", label: "High" }].map((e) => (
                      <button
                        key={e.key}
                        type="button"
                        className={`tag-chip ${gr_energy === e.key ? "active" : ""}`}
                        onClick={() => setGrEnergy(e.key)}
                      >
                        {e.label}
                      </button>
                    ))}
                  </div>
                </label>

                <label>
                  <span>Any dietary preferences?</span>
                  <select value={gr_diet} onChange={(e) => setGrDiet(e.target.value)}>
                    <option value="">No preference</option>
                    <option value="vegetarian">Vegetarian</option>
                    <option value="vegan">Vegan</option>
                    <option value="pescatarian">Pescatarian</option>
                    <option value="gluten-free">Gluten-free</option>
                    <option value="dairy-free">Dairy-free</option>
                  </select>
                </label>

                <label>
                  <span>Ingredients you want to include (optional)</span>
                  <input placeholder="e.g., mushrooms, spinach, eggs" value={gr_include} onChange={(e) => setGrInclude(e.target.value)} />
                </label>

                <label>
                  <span>Ingredients to avoid (optional)</span>
                  <input placeholder="e.g., cilantro, heavy cream" value={gr_exclude} onChange={(e) => setGrExclude(e.target.value)} />
                </label>

                <label>
                  <span>How much time do you have?</span>
                  <select value={gr_maxTime} onChange={(e) => setGrMaxTime(e.target.value)}>
                    <option value="">No preference</option>
                    <option value="15">Under 15 minutes</option>
                    <option value="30">Under 30 minutes</option>
                    <option value="45">Under 45 minutes</option>
                    <option value="60">1 hour+</option>
                  </select>
                </label>

                <div className="button-row" style={{ gridColumn: "1/-1" }}>
                  <button className="primary-button" type="button" onClick={handleGetRecipesClick} disabled={chatLoading}>
                    {chatLoading ? "Finding recipes…" : "Get recipes"}
                  </button>
                  <button className="secondary-button" type="button" onClick={handleCancelGetRecipe} disabled={chatLoading}>
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Recipe suggestions */}
          {currentRecipes.length > 0 && (
            <div className="recipes-section">
              <h4 className="recipes-title">Recipe suggestions:</h4>
              <div className="recipe-cards">
                {currentRecipes.map((item, idx) => (
                  <div key={idx} className="recipe-card">
                    <div className="recipe-header">
                      <h4 className="recipe-title">{item.recipe.title}</h4>
                      {item.recipe.time_minutes && (
                        <span className="recipe-time">
                          ~{item.recipe.time_minutes} min
                        </span>
                      )}
                    </div>
                    <p className="recipe-reason">{item.recipe.reason}</p>
                    {item.recipe.mood_effect && (
                      <p className="recipe-mood">
                        <em>Likely to leave you {item.recipe.mood_effect}</em>
                      </p>
                    )}
                    <button
                      className="recipe-button"
                      onClick={() => handleCookedThis(item.recipe)}
                    >
                      Cooked this
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Chat input */}
        <form className="chat-input-form" onSubmit={handleSendChat}>
          <textarea
            placeholder="Ask something like: What can I make that's high protein and quick?"
            rows={3}
            value={chatInput}
            onChange={(e) => setChatInput(e.target.value)}
            disabled={chatLoading}
          />
          {chatError && (
            <p className="chat-error-text">{chatError}</p>
          )}
          <div className="chat-footer">
            <button
              className="primary-button"
              type="submit"
              disabled={chatLoading || !chatInput.trim()}
            >
              {chatLoading ? "Thinking…" : "Ask Pantry AI"}
            </button>
          </div>
        </form>
      </div>

      {/* Feedback modal/panel */}
      {feedbackRecipe && (
        <div className="feedback-modal-overlay">
          <div className="feedback-modal">
            <h3>How was the {feedbackRecipe.title}?</h3>

            <div className="feedback-form">
              {/* Rating */}
              <div className="feedback-group">
                <label>Overall Rating:</label>
                <div className="rating-buttons">
                  {[1, 2, 3, 4, 5].map((num) => (
                    <button
                      key={num}
                      className={`rating-btn ${
                        feedbackData.rating === num ? "active" : ""
                      }`}
                      type="button"
                      onClick={() =>
                        setFeedbackData({ ...feedbackData, rating: num })
                      }
                    >
                      {num}
                    </button>
                  ))}
                </div>
              </div>

              {/* Liked tags */}
              <div className="feedback-group">
                <label>What did you like?</label>
                <div className="tag-chips">
                  {commonLikedTags.map((tag) => (
                    <button
                      key={tag}
                      className={`tag-chip ${
                        feedbackData.likedTags.includes(tag) ? "active" : ""
                      }`}
                      type="button"
                      onClick={() => toggleTag(tag, "liked")}
                    >
                      {tag}
                    </button>
                  ))}
                </div>
              </div>

              {/* Disliked tags */}
              <div className="feedback-group">
                <label>What didn&apos;t you like?</label>
                <div className="tag-chips">
                  {commonDislikedTags.map((tag) => (
                    <button
                      key={tag}
                      className={`tag-chip ${
                        feedbackData.dislikedTags.includes(tag) ? "active" : ""
                      }`}
                      type="button"
                      onClick={() => toggleTag(tag, "disliked")}
                    >
                      {tag}
                    </button>
                  ))}
                </div>
              </div>

              {/* Feel after */}
              <div className="feedback-group">
                <label>How did you feel afterward?</label>
                <div className="tag-chips">
                  {feelAfterOptions.map((option) => (
                    <button
                      key={option}
                      className={`tag-chip ${
                        feedbackData.feelAfter === option ? "active" : ""
                      }`}
                      type="button"
                      onClick={() =>
                        setFeedbackData({ ...feedbackData, feelAfter: option })
                      }
                    >
                      {option}
                    </button>
                  ))}
                </div>
              </div>

              {/* Notes */}
              <div className="feedback-group">
                <label>Any notes?</label>
                <textarea
                  placeholder="e.g., I added extra garlic..."
                  rows={2}
                  value={feedbackData.notes}
                  onChange={(e) =>
                    setFeedbackData({ ...feedbackData, notes: e.target.value })
                  }
                />
              </div>

              {/* Buttons */}
              <div className="feedback-buttons">
                <button
                  className="primary-button"
                  type="button"
                  onClick={handleSubmitFeedback}
                  disabled={feedbackLoading}
                >
                  {feedbackLoading ? "Saving…" : "Save feedback"}
                </button>
                <button
                  className="secondary-button"
                  type="button"
                  onClick={() => setFeedbackRecipe(null)}
                  disabled={feedbackLoading}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// PantryTab is now imported from PantryTab.tsx
  const [items, setItems] = useState<PantryItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [name, setName] = useState("");
  const [category, setCategory] = useState("");
  const [quantity, setQuantity] = useState<string>("");
  const [purchaseDate, setPurchaseDate] = useState<string>("");
  const [expirationDate, setExpirationDate] = useState<string>("");
  const [estimatedCalories, setEstimatedCalories] = useState<string>("");
  const [estimatedProtein, setEstimatedProtein] = useState<string>("");
  const [estimatedCarbs, setEstimatedCarbs] = useState<string>("");
  const [estimatedFat, setEstimatedFat] = useState<string>("");
  const [saving, setSaving] = useState(false);
  // Edit modal state
  const [editingItem, setEditingItem] = useState<PantryItem | null>(null);
  const [editSaving, setEditSaving] = useState(false);
  const [editName, setEditName] = useState("");
  const [editCategory, setEditCategory] = useState("");
  const [editQuantity, setEditQuantity] = useState<string>("");
  const [editPurchaseDate, setEditPurchaseDate] = useState<string>("");
  const [editExpirationDate, setEditExpirationDate] = useState<string>("");
  const [editEstimatedCalories, setEditEstimatedCalories] = useState<string>("");
  const [editEstimatedProtein, setEditEstimatedProtein] = useState<string>("");
  const [editEstimatedCarbs, setEditEstimatedCarbs] = useState<string>("");
  const [editEstimatedFat, setEditEstimatedFat] = useState<string>("");

  // Bulk import state
  const [bulkText, setBulkText] = useState<string>("");
  const [bulkLoading, setBulkLoading] = useState(false);

  // Load items on first render
  useEffect(() => {
    setLoading(true);
    fetchPantryItems()
      .then(setItems)
      .catch((err) => {
        console.error(err);
        setError("Could not load pantry items.");
      })
      .finally(() => setLoading(false));
  }, []);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!name.trim()) return;

    setSaving(true);
    setError(null);

    try {
      const qtyNum =
        quantity.trim() === "" ? undefined : Number.parseInt(quantity, 10) || 0;

      const parseOptionalNumber = (s: string) => {
        if (!s || s.trim() === "") return undefined;
        const n = Number(s);
        return Number.isNaN(n) ? undefined : n;
      };

      const newItem = await createPantryItem({
        name: name.trim(),
        category: category.trim() || undefined,
        quantity: qtyNum,
        purchase_date: purchaseDate || undefined,
        expiration_date: expirationDate || undefined,
        estimated_calories: parseOptionalNumber(estimatedCalories),
        estimated_protein_g: parseOptionalNumber(estimatedProtein),
        estimated_carbs_g: parseOptionalNumber(estimatedCarbs),
        estimated_fat_g: parseOptionalNumber(estimatedFat),
      });

      setItems((prev) => [...prev, newItem]);

      // clear form
      setName("");
      setCategory("");
      setQuantity("");
      setPurchaseDate("");
      setExpirationDate("");
      setEstimatedCalories("");
      setEstimatedProtein("");
      setEstimatedCarbs("");
      setEstimatedFat("");
    } catch (err) {
      console.error(err);
      setError("Could not save item.");
    } finally {
      setSaving(false);
    }
  }

  async function openEditModal(item: PantryItem) {
    setEditingItem(item);
    setEditName(item.name || "");
    setEditCategory(item.category || "");
    setEditQuantity(item.quantity !== undefined && item.quantity !== null ? String(item.quantity) : "");
    setEditPurchaseDate(item.purchase_date || "");
    setEditExpirationDate(item.expiration_date || "");
    setEditEstimatedCalories(item.estimated_calories !== undefined && item.estimated_calories !== null ? String(item.estimated_calories) : "");
    setEditEstimatedProtein(item.estimated_protein_g !== undefined && item.estimated_protein_g !== null ? String(item.estimated_protein_g) : "");
    setEditEstimatedCarbs(item.estimated_carbs_g !== undefined && item.estimated_carbs_g !== null ? String(item.estimated_carbs_g) : "");
    setEditEstimatedFat(item.estimated_fat_g !== undefined && item.estimated_fat_g !== null ? String(item.estimated_fat_g) : "");
  }

  async function handleSaveEdit(patch: Partial<import("./api").CreatePantryItemInput>) {
    if (!editingItem) return;
    setEditSaving(true);
    try {
      const updated = await (await import("./api")).updatePantryItem(editingItem.id, patch);
      setItems((prev) => prev.map((it) => (it.id === updated.id ? updated : it)));
      setEditingItem(null);
    } catch (err) {
      console.error(err);
      setError("Could not save changes.");
    } finally {
      setEditSaving(false);
    }
  }

  function closeEditModal() {
    setEditingItem(null);
  }

  async function handleBulkImport() {
    setBulkLoading(true);
    setError(null);
    try {
      const parsed = JSON.parse(bulkText);
      if (!Array.isArray(parsed)) throw new Error("Expected JSON array of items");
      const create = (await import("./api")).createPantryItemsBulk;
      const created = await create(parsed as any[]);
      setItems((prev) => [...prev, ...created]);
      setBulkText("");
    } catch (err) {
      console.error(err);
      setError("Bulk import failed: " + (err as Error).message);
    } finally {
      setBulkLoading(false);
    }
  }

  return (
    <div className="panel">
      <h2 className="panel-title">Pantry &amp; Recipes</h2>
      <p className="panel-subtitle">
        View and manage items and saved recipes. This is where CRUD will live.
      </p>

      <div className="split-grid">
        {/* Form side */}
        <div className="card">
          <h3 className="card-title">Add / Edit Pantry Item</h3>

          <form className="form-grid" onSubmit={handleSubmit}>
            <label>
              <span>Item name</span>
              <input
                placeholder="e.g., Black beans"
                value={name}
                onChange={(e) => setName(e.target.value)}
              />
            </label>

            <label>
              <span>Category</span>
              <input
                placeholder="e.g., canned, produce, snack"
                value={category}
                onChange={(e) => setCategory(e.target.value)}
              />
            </label>

            <label>
              <span>Quantity</span>
              <input
                placeholder="e.g., 2"
                value={quantity}
                onChange={(e) => setQuantity(e.target.value)}
              />
            </label>

            <label>
              <span>Purchase date</span>
              <input
                type="date"
                value={purchaseDate}
                onChange={(e) => setPurchaseDate(e.target.value)}
              />
            </label>

            <label>
              <span>Expiration date</span>
              <input
                type="date"
                value={expirationDate}
                onChange={(e) => setExpirationDate(e.target.value)}
              />
            </label>

            <label>
              <span>Estimated calories</span>
              <input
                type="number"
                placeholder="e.g., 300"
                value={estimatedCalories}
                onChange={(e) => setEstimatedCalories(e.target.value)}
              />
            </label>

            <label>
              <span>Estimated protein (g)</span>
              <input
                type="number"
                placeholder="e.g., 20"
                value={estimatedProtein}
                onChange={(e) => setEstimatedProtein(e.target.value)}
              />
            </label>

            <label>
              <span>Estimated carbs (g)</span>
              <input
                type="number"
                placeholder="e.g., 30"
                value={estimatedCarbs}
                onChange={(e) => setEstimatedCarbs(e.target.value)}
              />
            </label>

            <label>
              <span>Estimated fat (g)</span>
              <input
                type="number"
                placeholder="e.g., 10"
                value={estimatedFat}
                onChange={(e) => setEstimatedFat(e.target.value)}
              />
            </label>

            <div className="button-row">
              <button className="primary-button" type="submit" disabled={saving}>
                {saving ? "Saving…" : "Save item"}
              </button>
              <button
                className="secondary-button danger"
                type="button"
                disabled
                title="Delete will be added later"
              >
                Delete (future)
              </button>
            </div>
          </form>

          {error && (
            <p className="card-text small" style={{ color: "#b91c1c" }}>
              {error}
            </p>
          )}
          {!error && (
            <p className="card-text small">
              For the MVP, this form talks to our FastAPI backend. Next
              iterations will add editing and deleting.
            </p>
          )}
        </div>

        {/* Items / recipes side */}
        <div className="card">
          <h3 className="card-title">Current Items</h3>

          {loading ? (
            <p className="card-text">Loading items…</p>
          ) : items.length === 0 ? (
            <p className="card-text">
              No items yet. Add your first item on the left.
            </p>
          ) : (
            items.map((item) => (
              <div className="item-row" key={item.id}>
                <div>
                  <div className="item-name">{item.name}</div>
                  <div className="item-meta">
                          {item.category && <span>{item.category}</span>}
                          {item.quantity !== null &&
                            item.quantity !== undefined && (
                              <span>
                                {item.category ? " • " : ""}
                                {item.quantity} unit
                                {item.quantity === 1 ? "" : "s"}
                              </span>
                            )}

                          {item.purchase_date && (
                            <span>
                              {" • "}
                              Purchased: {item.purchase_date}
                            </span>
                          )}

                          {item.expiration_date && (
                            <span>
                              {" • "}
                              Expires: {item.expiration_date}
                            </span>
                          )}

                          {(item.estimated_calories || item.estimated_protein_g || item.estimated_carbs_g || item.estimated_fat_g) && (
                            <span>
                              {" • "}
                              Macros (est.): {item.estimated_calories ?? "-"} kcal,
                              {" "}{item.estimated_protein_g ?? "-"}g P,
                              {" "}{item.estimated_carbs_g ?? "-"}g C,
                              {" "}{item.estimated_fat_g ?? "-"}g F
                            </span>
                          )}
                    {!item.category &&
                      (item.quantity === null ||
                        item.quantity === undefined) && (
                        <span>No metadata</span>
                      )}
                  </div>
                </div>
                <div style={{ marginLeft: 12 }}>
                  <button
                    className="secondary-button"
                    onClick={() => openEditModal(item)}
                    style={{ marginRight: 8 }}
                  >
                    Edit
                  </button>
                </div>
              </div>
            ))
          )}

          <hr className="divider" />

          <div style={{ marginTop: 12 }}>
            <h4 className="card-title">Bulk import</h4>
            <p className="card-text small">Paste a JSON array of items (example below) and click Import.</p>
            <textarea
              value={bulkText}
              onChange={(e) => setBulkText(e.target.value)}
              placeholder='[{"name":"Black beans","quantity":2,"category":"canned","expiration_date":"2025-12-31","estimated_calories":300}]'
              rows={6}
              style={{ width: "100%", marginBottom: 8 }}
            />
            <div className="button-row">
              <button className="primary-button" onClick={handleBulkImport} disabled={bulkLoading}>
                {bulkLoading ? "Importing…" : "Import"}
              </button>
            </div>
          </div>

          <div className="recipes-block">
            <div className="recipes-title">Linked recipes (examples)</div>
            <ul>
              <li>Lemony Chickpea Pasta</li>
              <li>Creamy Spinach Pasta Bake</li>
            </ul>
          </div>

          <p className="card-text small">
            Future: this will be populated directly from the database using our
            real recipe tables.
          </p>
          {/* Edit modal */}
          {editingItem && (
            <div className="feedback-modal-overlay">
              <div className="feedback-modal">
                <h3>Edit item</h3>
                <div className="feedback-form">
                  <label>
                    <span>Name</span>
                    <input value={editName} onChange={(e) => setEditName(e.target.value)} />
                  </label>

                  <label>
                    <span>Category</span>
                    <input value={editCategory} onChange={(e) => setEditCategory(e.target.value)} />
                  </label>

                  <label>
                    <span>Quantity</span>
                    <input type="number" value={editQuantity} onChange={(e) => setEditQuantity(e.target.value)} />
                  </label>

                  <label>
                    <span>Purchase date</span>
                    <input type="date" value={editPurchaseDate} onChange={(e) => setEditPurchaseDate(e.target.value)} />
                  </label>

                  <label>
                    <span>Expiration date</span>
                    <input type="date" value={editExpirationDate} onChange={(e) => setEditExpirationDate(e.target.value)} />
                  </label>

                  <label>
                    <span>Estimated calories (kcal)</span>
                    <input type="number" value={editEstimatedCalories} onChange={(e) => setEditEstimatedCalories(e.target.value)} />
                  </label>

                  <label>
                    <span>Estimated protein (g)</span>
                    <input type="number" value={editEstimatedProtein} onChange={(e) => setEditEstimatedProtein(e.target.value)} />
                  </label>

                  <label>
                    <span>Estimated carbs (g)</span>
                    <input type="number" value={editEstimatedCarbs} onChange={(e) => setEditEstimatedCarbs(e.target.value)} />
                  </label>

                  <label>
                    <span>Estimated fat (g)</span>
                    <input type="number" value={editEstimatedFat} onChange={(e) => setEditEstimatedFat(e.target.value)} />
                  </label>

                  <div className="feedback-buttons">
                    <button
                      className="primary-button"
                      onClick={async () => {
                        if (!editingItem) return;
                        const parseOptionalNumber = (s: string) => {
                          if (!s || s.trim() === "") return undefined;
                          const n = Number(s);
                          return Number.isNaN(n) ? undefined : n;
                        };
                        const patch: Partial<import("./api").CreatePantryItemInput> = {
                          name: editName.trim() || undefined,
                          category: editCategory.trim() || undefined,
                          quantity: editQuantity.trim() === "" ? undefined : parseInt(editQuantity, 10) || 0,
                          purchase_date: editPurchaseDate || undefined,
                          expiration_date: editExpirationDate || undefined,
                          estimated_calories: parseOptionalNumber(editEstimatedCalories),
                          estimated_protein_g: parseOptionalNumber(editEstimatedProtein),
                          estimated_carbs_g: parseOptionalNumber(editEstimatedCarbs),
                          estimated_fat_g: parseOptionalNumber(editEstimatedFat),
                        };
                        await handleSaveEdit(patch);
                      }}
                      disabled={editSaving}
                    >
                      {editSaving ? "Saving…" : "Save changes"}
                    </button>
                    <button className="secondary-button" onClick={closeEditModal} disabled={editSaving}>
                      Cancel
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default function App() {
  const [activeTab, setActiveTab] = useState<Tab>("dashboard");
  const [theme, setTheme] = useState<Theme>("dark"); // default to dark mode

  useEffect(() => {
    let buffer = "";

    const handleKeyDown = (e: KeyboardEvent) => {
      // Ignore if you're typing in an input/textarea/contenteditable
      const active = document.activeElement as HTMLElement | null;
      if (
        active &&
        (active.tagName === "INPUT" ||
          active.tagName === "TEXTAREA" ||
          active.isContentEditable)
      ) {
        return;
      }

      // Only care about letter keys
      const char = e.key.toLowerCase();
      if (!/^[a-z]$/.test(char)) return;

      // Keep the last 5 characters typed
      buffer = (buffer + char).slice(-5);

      if (buffer.endsWith("dark")) {
        setTheme("dark");
      } else if (buffer.endsWith("light")) {
        setTheme("light");
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);

  return (
    <div className={`app ${theme}-theme`}>
      <header className="top-bar">
        <div>
          <h1 className="app-title">Kitchen Pal</h1>
          {/* subheader removed */}
        </div>
        <span className="demo-pill">Demo build</span>
      </header>

      <main className="main">
        <div className="tabs">
          <button
            className={`tab ${activeTab === "dashboard" ? "active" : ""}`}
            onClick={() => setActiveTab("dashboard")}
          >
            Dashboard
          </button>
          <button
            className={`tab ${activeTab === "chat" ? "active" : ""}`}
            onClick={() => setActiveTab("chat")}
          >
            Chat
          </button>
          <button
            className={`tab ${activeTab === "pantry" ? "active" : ""}`}
            onClick={() => setActiveTab("pantry")}
          >
            Pantry &amp; Recipes
          </button>
        </div>

        <section className="tab-panel">
          {activeTab === "dashboard" && <DashboardTab />}
          {activeTab === "chat" && <ChatTab />}
          {activeTab === "pantry" && <PantryTab />}
        </section>
      </main>
    </div>
  );
}
